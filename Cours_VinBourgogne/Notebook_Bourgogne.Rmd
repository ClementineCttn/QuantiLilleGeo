---
title: "R Notebook Quantilille 2023"
author: "Cl√©mentine Cottineau & Julie Vall√©e"
date: "30-06-2023"
output:
  html_document:
    df_print: paged
subtitle: "Module multiniveaux - Aspects g√©ographiques"
---

# Mise en place 

## Chargement des packages:

```{r, message=FALSE}
library(lme4) # pour la mod√©lisation multiniveau
library(multilevelTools) # pour l'analyse des mod√®les
library(lmerTest) # pour l'√©valuation des mod√®les
library(sf) # pour les objets spatiaux (cartes)
library(tidyverse) # pour la manipulation des donn√©es
library(readxl) # pour ouvrir les fichiers xlsx
library(ggrepel) # pour des √©tiquettes de graphiques propres
```

## Chargement des donn√©es:

### Jeu de donn√©es de niveau 1

Il s'agit des vignobles de Bourgogne. On a dans un tableau les caract√©ristiques de 2391 vignobles en termes de:

- prix moyen du vin
- qualit√© p√©dologique et m√©t√©o (radiations solaires, pluie, etc.)
- appellation d'origine contr√¥l√©e en 5 niveaux (C√¥teaux bourgignons <  Bourgogne < Village < Premier cru < Grand cru.)
- surface


```{r}
vignobles <- st_read("Data/Geo/Vignobles_prix.shp",
                     stringsAsFactors = T) %>% 
  st_transform(crs = "EPSG:2154")
summary(vignobles)

vignobles %>% 
  dplyr::filter(LIBCOM == "FLAGEY-ECHEZEAUX" & NIVEAU == "Premier cru")

```


### Jeu de donn√©es de niveau 2

Il s'agit des communes de C√¥te d'Or. On a dans un tableau les caract√©ristiques de 31 communes en termes de:

- superficie
- population
- c√¥te d'appellation
- hierarchie administrative


```{r}
communes <- st_read("Data/Geo/communes.shp",
                     stringsAsFactors = T) %>% 
  st_transform(crs = "EPSG:2154")
summary(communes)

```

## Visualisation des donn√©es:

Avec `ggplot`, utilisation de `geom_sf` pour les objets spatiaux.

```{r}
ggplot(data = vignobles) +
  geom_sf(aes(fill = log(PrixMoy)), lwd=0.01, colour="white")  +
  scale_fill_viridis_c(option = "viridis")
```

Pour des √©tiquettes r√©actives, on utilise `geom_text_repel`:

```{r}
ggplot(data = communes) +
  geom_sf(aes(fill = Cote), lwd=0.01, colour="white") +
  geom_text_repel(data = communes[communes$population > 1,],
                        aes(label = nom_comm, geometry = geometry),
                  stat = "sf_coordinates",size=3, colour="black")

```

## Cr√©ation de variables niveau 2 √† partir d'aggr√©gation de donn√©es niveau 1

Info sur la distribution des prix, des surfaces, des qualit√©s physiques des vignobles, etc.
```{r}

Vignobles_par_communes <- as_tibble(vignobles) %>%
  group_by(LIBCOM) %>%
  summarise(aire_vignoble = sum(SURFACE),
            MoyPond_b = sum(SCORE_b * SURFACE) / sum(SURFACE),
            N_Parcelles = n(),
            Prix_moyen = mean(PrixMoy,na.rm=T),
            Prix_median = median(PrixMoy,na.rm=T),
            ) 
```


Info sur les appellations d'origine contr√¥l√©e:
```{r}
Vignobles_par_communes_par_AOC <- as_tibble(vignobles) %>%
  group_by(LIBCOM, NIVEAU) %>%
  summarise(N_Parcelles = n()
  ) %>%  
  pivot_wider(names_from = NIVEAU, values_from = N_Parcelles) %>%
  replace_na(list(`Bourgogne` = 0,
                  `Grand cru`=0,
                  `Premier cru`=0,
                  `Village`=0,
                  `Coteaux b.`=0))
```

## Jointure et proportions d'AOC
```{r}

communes_final <- left_join(Vignobles_par_communes,
Vignobles_par_communes_par_AOC, by="LIBCOM") %>%
  left_join(communes,., by=c("nom_comm"="LIBCOM")) %>%
  mutate(share_Bourgogne = `Bourgogne` / N_Parcelles * 100,
         share_GdCru = `Grand cru` / N_Parcelles * 100,
         share_PmCru = `Premier cru` / N_Parcelles * 100,
         share_Village = `Village` / N_Parcelles * 100,
         share_Coteau = `Coteaux b.` / N_Parcelles * 100,
         share_PmGrCru = (`Premier cru`  + `Grand cru`) / N_Parcelles * 100,
         share_PmGrCruVill = (`Premier cru`  + `Grand cru` + `Village`) / N_Parcelles * 100)


head(communes_final)

# Prix moyen des vins estim√©s par commune
ggplot(data = communes_final) +
  geom_sf(aes(fill = Prix_moyen), lwd=0.01, colour="white")  +
  scale_fill_gradient(low = "white", high="red") +
  geom_text_repel(data = communes_final[communes_final$Prix_moyen > 100 ,],
                  aes(label = nom_comm, geometry = geometry),
                  stat = "sf_coordinates",size=3, colour="black")



# Qualit√© moyenne des parcelles par commune
ggplot(data = communes_final) +
  geom_sf(aes(fill = MoyPond_b), lwd=0.01, colour="white")  +
  scale_fill_gradient(low = "white", high="goldenrod4") + 
  geom_text_repel(data = communes_final[communes_final$MoyPond_b > 80
                                      | communes_final$MoyPond_b < 65 ,], 
                  aes(label = nom_comm, geometry = geometry),
                  stat = "sf_coordinates",size=3, colour="black")

# Proportion de parcelles en grand cru par commune
ggplot(data = communes_final) +
  geom_sf(aes(fill = share_GdCru), lwd=0.01, colour="white")  +
  scale_fill_gradient(low = "white", high="goldenrod") +
  geom_text_repel(data = communes_final[communes_final$share_GdCru > 8 ,],
                  aes(label = nom_comm, geometry = geometry),
                  stat = "sf_coordinates",size=3, colour="black")


# Proportion de parcelles en premier ou grand cru par commune
ggplot(data = communes_final) +
  geom_sf(aes(fill = share_PmGrCru), lwd=0.01, colour="white")  +
  scale_fill_gradient(low = "white", high="gold") +
  geom_text_repel(data = communes_final[communes_final$share_PmGrCru > 30 ,],
                  aes(label = nom_comm, geometry = geometry),
                  stat = "sf_coordinates",size=3, colour="black")

```

## Rapatriation des donn√©es communes au niveau vignoble

```{r}
communes_final_tib <- as_tibble(communes_final) %>%
  select(-geometry)

vignobles_final <- left_join(vignobles,communes_final_tib, 
                              by=c("LIBCOM"= "nom_comm"))

summary(vignobles_final)
```


# Mod√©lisation multiniveaux

## variable a expliquer: le prix moyen du üç∑ 

```{r}
summary(vignobles_final$PrixMoy)

ggplot(data=vignobles_final, aes(x=PrixMoy)) +
  geom_histogram(fill="coral1")

# Passage en log pour une distribution plus normale
vignobles_final$LogPrix <- log(vignobles_final$PrixMoy)

ggplot(data=vignobles_final, aes(x=LogPrix)) +
  geom_histogram(fill="coral3") +
  geom_vline(aes(xintercept=mean(LogPrix)),   
             color="black", linetype="dashed", size=1)


```

## variables explicatives niveau 1:
```{r}
#Score qualit√© geographique (pente, geologie, pedologie, precipitations):
ggplot(data=vignobles_final, aes(x=SCORE_b)) +
  geom_histogram(fill="brown1")

#Surface:
ggplot(data=vignobles_final, aes(x=SURFACE)) +
  geom_histogram(fill="brown2")

#Niveau d'aoc:
positions <- c("Coteaux b.", "Bourgogne", "Village",
               "Premier cru", "Grand cru")
ggplot(data=vignobles_final, aes(x=NIVEAU)) +
  geom_bar(fill="brown3") +
  scale_x_discrete(limits = positions)

#Source info prix:
ggplot(data=vignobles_final, aes(x=Source)) +
   geom_bar(fill="brown4") 
```

## variables explicatives niveau 2:
```{r}

#Population de la commune
ggplot(data=communes_final, aes(x=population)) +
  geom_histogram(fill="aquamarine1", bins = 5)

#Part de grand et premier cru de la commune
ggplot(data=communes_final, aes(x=share_PmGrCru)) +
  geom_histogram(fill="aquamarine3", bins = 5)

#Cote de nuit ou cote de beaune:
pos_cote <- c("C√¥te de Nuit", "C√¥te de Beane", "C√¥te D'or")
ggplot(data=communes_final, aes(x=Cote)) +
  geom_bar(fill="aquamarine4") +
  scale_x_discrete(limits = pos_cote)

#Qualite moyenne de la commune
ggplot(data=communes_final, aes(x=MoyPond_b)) +
  geom_histogram(fill="darkslategrey", bins = 5)

```

## Centrage-r√©duction-s√©lection des variables

```{r}
vignobles_final_cr <- vignobles_final %>%
  mutate(LogPrix = scale(as.numeric(LogPrix)), 
         Surface = scale(as.numeric(SURFACE)), 
         Quality = scale(as.numeric(SCORE_b)), 
         MeanQuality = scale(as.numeric(MoyPond_b)), 
         ShareGdCru = scale(as.numeric(share_GdCru))) %>%
  select(LogPrix, Surface, Quality, MeanQuality, ShareGdCru,
         LIBCOM, Source, Cote, Concat)

summary_stat <- data.frame()
```

## Mod√®le √† un seul niveau

```{r}
L1 <- lm(LogPrix~Quality+Surface+Source, data=vignobles_final_cr)

summary(L1)
```

## Mod√®le nul √† 2 niveaux

```{r}
mnnull <- lmer(LogPrix ~ 1 + (1 | LIBCOM), data=vignobles_final_cr, REML=F, na.action=na.omit)
summary(mnnull)

# La variance r√©siduelle du niveau commune est de: 1.34
vrn2 <- summary(mnnull)$varcor[1][[1]][[1]]
# La variance r√©siduelle du niveau vignoble est de: 0.25
vrn1 <- as.data.frame(summary(mnnull)$varcor)[2,]$vcov 
# Donc la correlation intraclasse ICC est de 0.84
icc <- vrn2 / (vrn1 + vrn2)
icc

# Ou plus simplement
performance::icc(mnnull)

summary_stat["MNNull","N"] <- dim(mnnull@frame)[1] 
summary_stat["MNNull","LogLik" ] <- summary(mnnull)$AIC[3][[1]] 
summary_stat["MNNull", "AIC" ] <-summary(mnnull)$AIC[1][[1]]
summary_stat["MNNull", "BIC" ] <- summary(mnnull)$AIC[2][[1]]
summary_stat["MNNull", "Deviance" ] <- summary(mnnull)$AIC[4][[1]]
summary_stat["MNNull", "Total_Var" ] <- vrn2 + vrn1
summary_stat["MNNull", "ICC" ] <- performance::icc(mnnull)[[1]]
summary_stat["MNNull", "InterClass" ] <- vrn1 / (vrn2 + vrn1)


summary_stat


```

